#include <stdbool.h>
#include <stdarg.h>

#ifndef TYPES_INCLUDED
#define TYPES_INCLUDED
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;
typedef unsigned long long u64;

typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;

typedef float f32;
typedef double f64;
#endif

#ifndef ZUI_INCLUDED
#define ZUI_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WIN32
#define ZUI_API __declspec(dllexport)
#else
#define ZUI_API
#endif

#ifdef DEBUG
// export all private functions to help stack trace
#define ZUI_PRIVATE ZUI_API
#else
#define ZUI_PRIVATE static
#endif

#define Z_AUTO 32766
#define Z_AUTO_ALL 32767
#define Z_FILL -1

typedef struct zcmd { u16 id, bytes; } zcmd;
typedef struct zcolor { u8 r, g, b, a; } zcolor;
typedef union zvec2 { struct { i16 x, y; }; i16 e[2]; } zvec2;
typedef union zrect { struct { i16 x, y, w, h; }; struct { zvec2 pos; zvec2 sz; }; i16 e[4]; } zrect;

enum ZUI_KEYS {
    ZK_L_SHIFT = 1 << 0,
    ZK_R_SHIFT = 1 << 1,
    ZK_SHIFT = ZK_L_SHIFT | ZK_R_SHIFT,
    ZK_L_CTRL = 1 << 2,
    ZK_R_CTRL = 1 << 3,
    ZK_CTRL = ZK_L_CTRL | ZK_R_CTRL,
    ZK_L_ALT = 1 << 4,
    ZK_R_ALT = 1 << 5,
    ZK_ALT = ZK_L_ALT | ZK_R_ALT,
    ZK_CAPSLOCK = 1 << 6,
    ZK_SUPER = 1 << 7,
#if defined(_WIN32)
    ZK_SHORTCUT = ZK_CTRL,
#elif defined(__APPLE__) && defined(__MACH__)
    ZK_SHORTCUT = ZK_SUPER,
#endif
};

enum ZUI_MOUSE {
    ZM_LEFT_CLICK = 1,
    ZM_RIGHT_CLICK = 2,
    ZM_MIDDLE_CLICK = 4
};

enum ZUI_STYLETYPE {
    ZS_COLOR = 0,
    ZS_VEC2 = 1,
    ZS_INT = 2,
    ZS_FLOAT = 3
};

enum ZUI_STYLEABLE {
    ZS_DONE = 0,
    ZSC_BACKGROUND,
    ZSC_FOREGROUND,
    ZSC_SECONDARY,
    ZSC_HOVERED,
    ZSC_UNFOCUSED,
    ZSV_PADDING,
    ZSV_SPACING,
    ZSV_BORDER,
    ZS_LAST,
};

enum ZUI_FLAGS {
    ZJ_CENTER = 0, // justification flags
    ZJ_LEFT =   1 << 0,
    ZJ_RIGHT =  1 << 1,
    ZJ_UP =     1 << 2,
    ZJ_DOWN =   1 << 3,
    ZF_PERSIST = (ZJ_LEFT | ZJ_RIGHT | ZJ_UP | ZJ_DOWN),
    ZF_CONTAINER = 1 << 4, // a container (saves style changes for itself and children)
    ZF_END_PARENT = 1 << 5,
    ZF_TABBABLE =  1 << 6, // pressing tab can focus to this element
    ZF_DISABLED =  1 << 7, // not selectable (ui_pos ignores it for hovered/focused consideration)
    ZF_FILL_X    = 1 << 8, // recalc width after initial autosize
    ZF_FILL_Y    = 1 << 9, // recalc height after initial autosize
    ZF_LAST_CHILD = 1 << 10,  // this is the final child of its parent
    //ZF_INDEPENDENT = 1 << 12, // size and position determined by itself
    ZF_SELF_POS = 1 << 11,    // position and cliprect determined by itself
    ZF_SELF_WIDTH = 1 << 12,  // width determined by itself
    ZF_SELF_HEIGHT = 1 << 13, // height determined by itself
    ZF_WRAPPER = 1 << 14,  // whenever a child is added to this element, apply custom handler
};

// commands generated by zui
enum ZUI_CMDS {
    ZCMD_INIT,
    ZCMD_TICK,
    ZCMD_TICK_BLOCKING,
    ZCMD_REDRAW,
        // _ZCMD_INIT,     // new client
    ZCMD_CLOSE,
        // _ZCMD_CLOSE,    // client disconnects
    ZCMD_RENDER_BEGIN,
    ZCMD_RENDER_END,
    ZCMD_REG_FONT,
        // _ZCMD_FONT,     // client tells whether it was successful
    ZCMD_DRAW_CLIP,
    ZCMD_DRAW_RECT,
    ZCMD_DRAW_TEXT,
    ZCMD_DRAW_BEZIER,
    ZCMD_DRAW_LINES,
        // _ZCMD_KEYCODE,   // zui_key_char
        // _ZCMD_MOUSE,     // zcmd *zui_mouse_*
        // _ZCMD_RESIZE,    // zcmd *zui_resize(u16 w, u16 h);
    ZCMD_SET_CLIPBOARD,
    ZCMD_GET_CLIPBOARD,
        // _ZCMD_CLIPBOARD, // zcmd *zui_clipboard(char *);
    ZCMD_GLYPH_SZ,
    ZCMD_TIMESTAMP
        // _ZCMD_GLYPH_SZ,  // zcmd *zui_set_glyph(u16 font_id, i32 codepoint, zvec2 sz);
};

typedef struct zcmd_clip { zcmd header; zrect rect; } zcmd_clip;                                          // set clip rect
typedef struct zcmd_rect { zcmd header; zrect rect; zcolor color; } zcmd_rect;                            // draw rect
typedef struct zcmd_text { zcmd header; zvec2 pos;  zcolor color; u16 font_id; char text[0]; } zcmd_text; // draw text
typedef struct zcmd_lines { zcmd header; zcolor color; i32 width; zvec2 points[0]; } zcmd_bezier, zcmd_lines; // draw bezier
typedef struct zcmd_get_clipboard { zcmd header; char *response; } zcmd_get_clipboard;                    // get clipboard
typedef struct zcmd_set_clipboard { zcmd header; char text[0]; } zcmd_set_clipboard;                      // set clipboard
typedef struct zcmd_reg_font { zcmd header; u16 font_id; u16 size; u16 response_height; char family[0]; } zcmd_reg_font; // register font
typedef struct zcmd_glyph_sz { zcmd header; u16 font_id; i32 codepoint; zvec2 response; } zcmd_glyph_sz; // get text size
typedef struct zcmd_timestamp { zcmd header; u64 resp_ns; } zcmd_timestamp;
typedef union {
    zcmd base;
    zcmd_clip clip;
    zcmd_rect rect;
    zcmd_text text;
    zcmd_lines lines;
    zcmd_bezier bezier;
    zcmd_reg_font font;
    zcmd_glyph_sz glyph_sz;
    zcmd_timestamp timestamp;
    zcmd_set_clipboard set_clipboard;
    zcmd_get_clipboard get_clipboard;
} zcmd_any;

typedef void(*zui_render_fn)(zcmd_any *cmd, void *user_data);
typedef void(*zui_log_fn)(char *fmt, va_list args, void *user_data);
typedef void(*zui_init_fn)(void *user_data);
typedef void(*zui_frame_fn)(void *user_data);
typedef void(*zui_close_fn)(void *user_data);

typedef struct zimpl {
    void *impl_data;
    zui_render_fn renderer;
} zimpl;

void zui_launch(zimpl implementation, void *settings);

typedef struct zccmd_mouse { zcmd header; zvec2 pos; u16 state; } zccmd_mouse;     // mouse movement / state
typedef struct zccmd_keys { zcmd header; u32 key; u16 modifiers; } zccmd_keys;     // key presses
//typedef struct zccmd_glyph { zcmd header; zglyph_data c; } zccmd_glyph;            // sent every time a new glyph needs to be displayed
typedef struct zccmd_win { zcmd header; zvec2 sz; } zccmd_win;                     // new window size
typedef struct zccmd_font { zcmd header; u32 status; } zccmd_stat;                 // response to server command
typedef union zccmd {
    zcmd        base;
    zccmd_mouse mouse;
    zccmd_keys  keys;
    //zccmd_glyph glyph;
    zccmd_win   win;
    zccmd_stat  status;
} zccmd;

enum ZUI_WIDGETS {
    ZW_FIRST,
    ZW_BLANK = ZW_FIRST,
    ZW_WINDOW,
    ZW_BOX,
    ZW_POPUP,
    ZW_LABEL,
    ZW_LABELF,
    ZW_ROW,
    ZW_COL,
    ZW_SCROLL,
    ZW_BTN,
    ZW_CHECK,
    ZW_TEXT,
    ZW_COMBO,
    ZW_COMBO_DROPDOWN,
    ZW_DROPDOWN,
    ZW_GRID,
    ZW_TABSET,
    ZW_SURROGATE,
    ZW_LAST
};

#ifndef ZUI_DEBUG
typedef struct zw_base { u16 id, bytes; i32 next, zindex, flags; zrect bounds; zrect used; } zw_base;
typedef struct zw_cont { u16 id, bytes; i32 next, zindex, flags; zrect bounds; zrect used; u16 children; u16 style_edits; } zw_cont;
#else
typedef struct zw_base { u16 id, bytes; i32 next, zindex, flags; zrect bounds; zrect used; u32 meta; } zw_base;
typedef struct zw_cont { u16 id, bytes; i32 next, zindex, flags; zrect bounds; zrect used; u32 meta; u16 children; u16 style_edits; } zw_cont;
#endif

#define Z_WIDGET union { zcmd cmd; zw_base widget; }
#define Z_CONT   union { zcmd cmd; zw_base widget; zw_cont cont; }

typedef struct zd_text { i32 flags, index, ofs, selection; } zd_text;
typedef struct zd_combo { u8 index; u8 toggle; u8 dropdown; u8 _; } zd_combo;
typedef struct zd_popup { bool init; bool dragging; zvec2 pos; } zd_popup;
typedef struct zd_scroll { zvec2 pos; bool dragging; } zd_scroll;

typedef struct zw_box    { Z_CONT; } zw_box;
typedef struct zw_dropdown { Z_CONT; i32 parent, direction; u8 *state; } zw_dropdown;
typedef struct zw_popup  { Z_CONT; zd_popup *state; } zw_popup;
typedef struct zw_layout { Z_CONT; i32 count; i16 sizes[0]; } zw_layout;
typedef struct zw_grid   { Z_CONT; i32 order; i16 rows, cols, data[0]; } zw_grid;
typedef struct zw_tabset { Z_CONT; char *cstabs; i32 *state; u16 label_cnt; u16 tabheight; } zw_tabset;
typedef struct zw_text   { Z_WIDGET; char *buffer; i32 len; zd_text *state; } zw_text;
typedef struct zw_btn    { Z_CONT; u8 *state, id; } zw_btn;
typedef struct zw_check  { Z_WIDGET; u8 *state; } zw_check;
typedef struct zw_surrogate { Z_WIDGET; i32 id_offset; } zw_surrogate;

struct zw_combo;
typedef char *extract_txt_fn(zw_base *data, i32 *len);
typedef struct zw_combo  { Z_CONT; zd_combo *state; i32 tooltip; extract_txt_fn *fn; } zw_combo;

typedef struct zw_label  { Z_WIDGET; char *text; i32 len; } zw_label;
typedef struct zw_labelf { Z_WIDGET; char text[0]; } zw_labelf;
typedef struct zw_scroll { Z_CONT; bool xbar, ybar; zd_scroll *state; } zw_scroll;

#ifdef ZUI_DEV
#define FOR_CHILDREN(ui) for(zw_base* child = _ui_get_child((zw_base*)ui); child; child = _ui_next(child))
#define FOR_SIBLINGS(ui, sibling) for(zw_base* child = (zw_base*)sibling; child; child = _ui_next(child))
#define FOR_N_SIBLINGS(ui, sibling, n) for(i32 i = 0; sibling && i < n; sibling = _ui_next(sibling), i++)
#define SWAP(type, a, b) { type tmp = a; a = b; b = tmp; }

ZUI_API zw_base *_ui_widget(i32 index);
ZUI_API i32 _ui_index(zw_base *ui);
ZUI_API zw_base *_ui_next(zw_base *widget);
ZUI_API void *_ui_alloc(i32 id, i32 size);
ZUI_API void *_cont_alloc(i32 id, i32 size);
ZUI_API zcmd_any *_draw_alloc(u16 id, u16 size, i32 zindex);
ZUI_API zrect _rect_add(zrect a, zrect b);
ZUI_API zrect _rect_pad(zrect r, zvec2 padding);
ZUI_API void _push_rect_cmd(zrect rect, zcolor color, i32 zindex);
ZUI_API void _push_clip_cmd(zrect rect, i32 zindex);
ZUI_API void _push_text_cmd(u16 font_id, zvec2 coord, zcolor color, char *text, i32 len, i32 zindex);
ZUI_API void _push_lines_cmd(i32 cnt, zvec2 *points, i32 width, zcolor color, i32 zindex);
ZUI_API void _push_bezier_cmd(i32 cnt, zvec2 *points, i32 width, zcolor color, i32 zindex);
ZUI_API zvec2 _vec_max(zvec2 a, zvec2 b);
ZUI_API zvec2 _vec_min(zvec2 a, zvec2 b);
ZUI_API zvec2 _vec_add(zvec2 a, zvec2 b);
ZUI_API zvec2 _vec_sub(zvec2 a, zvec2 b);
ZUI_API i32 _vec_distsq(zvec2 a, zvec2 b);
ZUI_API bool _vec_within(zvec2 v, zrect bounds);
ZUI_API bool _rect_within(zrect r, zrect bounds);
ZUI_API bool _rect_intersect(zrect a, zrect b, zrect *intersect);
ZUI_API void _rect_justify(zrect *used, zrect bounds, i32 justification);
ZUI_API void _ui_schedule_focus(zw_base *widget);
ZUI_API zw_base *_ui_find_with_flag(zw_base *start, u32 flags);
ZUI_API zw_base *_ui_get_child(zw_base *ui);
ZUI_API bool _ui_pressed(i32 buttons);
ZUI_API bool _ui_dragged(i32 buttons);
ZUI_API bool _ui_clicked(i32 buttons);
ZUI_API bool _ui_released(i32 buttons);
ZUI_API void _ui_print(zw_base *cmd, int indent, bool expand_children);
ZUI_API zvec2 _ui_mpos();
ZUI_API zvec2 _ui_mdelta();
ZUI_API i16 _ui_sz(zw_base *ui, bool axis, i16 bound);
ZUI_API bool _ui_is_child(zw_base *container, zw_base *other);
ZUI_API bool _ui_hovered(zw_base *ui);
ZUI_API bool _ui_cont_hovered(zw_base *ui);
ZUI_API bool _ui_focused(zw_base *ui);
ZUI_API bool _ui_cont_focused(zw_base *ui);
ZUI_API void _ui_pos(zw_base *ui, zvec2 pos, i32 zindex);
ZUI_API void _ui_draw(zw_base *ui);
ZUI_API void zui_register(i32 widget_id, char *widget_name, void *size_cb, void *pos_cb, void *draw_cb);
ZUI_API void zui_default_style(u32 widget_id, ...);
ZUI_API i32 zui_new_sid();
ZUI_API i32 zui_new_wid();
#endif

#ifdef ZUI_UTF8
ZUI_API i32  utf8_val(char *text, u32 codepoint);
ZUI_API i32  utf8_len(u32 codepoint);
ZUI_API void utf8_print(char *text, u32 codepoint, i32 len);
#endif

#ifdef ZUI_BUF
typedef struct zui_buf {
    i32 used;
    u16 cap;
    u16 alignsub1;
    u8 *data;
} zui_buf;
ZUI_API void zbuf_resize(zui_buf *l);
ZUI_API void zbuf_init(zui_buf *l, i32 cap, i32 alignment);
ZUI_API void *zbuf_alloc(zui_buf *l, i32 size);
ZUI_API i32  zbuf_align(zui_buf *l, i32 n);
ZUI_API void *zbuf_peek(zui_buf *l, i32 size);
ZUI_API void *zbuf_pop(zui_buf *l, i32 size);
#endif

#ifdef ZUI_MAP
typedef struct zmap zmap;
ZUI_API void zmap_init(zmap *map);
ZUI_API u32  zmap_hash(u32 n);
ZUI_API void zmap_set(zmap *map, u32 key, u32 value);
ZUI_API bool zmap_get(zmap *map, u32 key, u32 *value);
#endif

// CLIENT COMMANDS
// void zui_client_init(zui_client_fn send, zui_render_fn recv, zui_log_fn logger, void *user_data);
// void zui_client_push_raw(char *bytes, i32 len);
// void zui_client_push(zscmd *cmd);
// void zui_client_respond(i32 value);
// void zui_client_render();

ZUI_API void zui_log(char *fmt, ...);

// Used when manually ticking to pump window events.
// If blocking, waits for the next window event.
// If non-blocking, immediately returns if no events scheduled.
ZUI_API void zui_tick(bool blocking);

// used alongside manual ticking to get a specific fps, or draw as needed.
ZUI_API void zui_redraw();

ZUI_API void zui_mouse_down(u16 btn);
ZUI_API void zui_mouse_up(u16 btn);
ZUI_API void zui_mouse_move(zvec2 pos);
ZUI_API void zui_mouse_scroll(i32 delta);
ZUI_API void zui_key_mods(u16 mod);
ZUI_API void zui_key_char(i32 c);
ZUI_API bool zui_key_pressed(i32 c);
ZUI_API void zui_resize(u16 width, u16 height);

// SERVER COMMANDS
ZUI_API void zui_init(zui_render_fn renderer, zui_log_fn logger, void *user_data);
ZUI_API void zui_push(zccmd *cmd);
ZUI_API void zui_render();
ZUI_API i64 zui_ts();

ZUI_API void zui_print_tree();
ZUI_API void zui_print_active();

ZUI_API void zui_close();
ZUI_API void zui_blank();
ZUI_API void zui_box();
ZUI_API void zui_popup(i32 width, i32 height, zd_popup *popup);
ZUI_API void zui_justify(u32 justification);
ZUI_API void zui_fill(u32 axis);
ZUI_API void zui_disable();

// sets the style for the next container
ZUI_API void zui_style(u32 widget_id, ...);

ZUI_API zcolor zui_stylec(u16 widget_id, u16 style_id);
ZUI_API zvec2  zui_stylev(u16 widget_id, u16 style_id);
ZUI_API float  zui_stylef(u16 widget_id, u16 style_id);
ZUI_API i32    zui_stylei(u16 widget_id, u16 style_id);

//void zui_size(i32 w, i32 h);
ZUI_API u16  zui_new_font(char *family, i32 size);
//zvec2 zui_text_sz(u16 id, char *text, i32 len);
ZUI_API void zui_font(u16 id);

ZUI_API void zui_end();
ZUI_API void zui_window();
ZUI_API zvec2 zui_window_sz();
ZUI_API void zui_label(const char *text);
ZUI_API void zui_labeln(char *text, i32 len);
ZUI_API void zui_labelf(const char *fmt, ...);
ZUI_API void zui_sliderf(char *tooltip, f32 min, f32 max, f32 *value);
ZUI_API void zui_slideri(char *tooltip, i32 min, i32 max, i32 *value);
ZUI_API void zui_combo_set(zd_combo *state, i32 index);
ZUI_API i32  zui_combo(char *tooltip, zd_combo *state);
ZUI_API i32  zui_combo_txt(char *tooltip, char *csoptions, zd_combo *state);
ZUI_API bool zui_radio_btn(u8 *state, u8 id);
ZUI_API bool zui_button(u8 *state);
ZUI_API bool zui_button_txt(const char *text, u8 *state);
ZUI_API bool zui_check(u8 *state);
ZUI_API void zui_dropdown(i32 direction, u8 *state);
ZUI_API void zui_scroll(bool xbar, bool ybar, zd_scroll *state);
ZUI_API void zui_validator(bool(*validator)(char *text));
ZUI_API void zui_text(char *buffer, i32 len, zd_text *state);
ZUI_API void zui_textbox(char *buffer, i32 len, i32 *state);
ZUI_API void zui_col(i32 n, ...);
ZUI_API void zui_row(i32 n, ...);


ZUI_API void zui_grid(i32 cols, i32 rows, ...);
ZUI_API void zui_tabset(char *cstabs, i32 *state);

#ifdef ZUI_DEBUG
#ifndef ZUI_SRC
void zui_meta(i32 line, char *file);
#define zui_col(...) zui_meta(__LINE__, __FILE__); zui_col(__VA_ARGS__)
#define zui_row(...) zui_meta(__LINE__, __FILE__); zui_row(__VA_ARGS__)
#endif
#endif

#ifdef __cplusplus
}
#endif
#endif
