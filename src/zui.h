#include <stdbool.h>
#include <stdarg.h>

#ifndef TYPES_INCLUDED
#define TYPES_INCLUDED
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;
typedef unsigned long long u64;

typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;

typedef float f32;
typedef double f64;
#endif

#ifndef ZUI_INCLUDED
#define ZUI_INCLUDED

#ifdef __cplusplus 
extern "C" {
#endif

#define Z_AUTO ((u16)-1)

typedef struct zcmd { u16 id, bytes; } zcmd;
typedef struct zcolor { u8 r, g, b, a; } zcolor;
typedef union zvec2 { struct { u16 x, y; }; u16 e[2]; } zvec2;
typedef union zrect { struct { u16 x, y, w, h; }; struct { u16 pos[2]; u16 sz[2]; }; } zrect;

/*
#define ZUI_IMPL
#include <zui-gdi.h>
zui_launch(ZUI_GDI, &(zgdi_args) {
    .width  = 800,
    .height = 600,
    .title  = "Hello Zui!",
    .init   = ...
    .frame  = ...
    .close  = ...
    .tick   = ... // if set, zui's events are managed externally
});

#include <zui-net.h>
void on_connect(i32 connections, u32 ip);
void on_disconnect(i32 connections, u32 ip) {
    if(connections == 0)
        zui_close();
}

zui_launch(ZUI_NET, &(znet_args) {
    .ip = znet_ip("127.0.0.1"),
    .socket_type = Z_UDP,
    .max_connections = 1
    .on_connect    = ...
    .on_disconnect = ...
    .init   = ...
    .frame  = ...
    .close  = ...
    .tick   = true // if set to true, zui's event loop is managed by zui_tick()
});
*/

enum ZUI_KEYS {
    ZK_L_SHIFT = 1 << 0,
    ZK_R_SHIFT = 1 << 1,
    ZK_SHIFT = ZK_L_SHIFT | ZK_R_SHIFT,
    ZK_L_CTRL = 1 << 2,
    ZK_R_CTRL = 1 << 3,
    ZK_CTRL = ZK_L_CTRL | ZK_R_CTRL,
    ZK_L_ALT = 1 << 4,
    ZK_R_ALT = 1 << 5,
    ZK_ALT = ZK_L_ALT | ZK_R_ALT,
    ZK_CAPSLOCK = 1 << 6,
    ZK_SUPER = 1 << 7,
#if defined(_WIN32)
    ZK_SHORTCUT = ZK_CTRL,
#elif defined(__APPLE__) && defined(__MACH__)
    ZK_SHORTCUT = ZK_SUPER,
#endif
};

enum ZUI_MOUSE {
    ZM_LEFT_CLICK = 1,
    ZM_RIGHT_CLICK = 2,
    ZM_MIDDLE_CLICK = 4
};

enum ZUI_STYLETYPE {
    ZS_COLOR = 0,
    ZS_VEC2 = 1,
    ZS_INT = 2,
    ZS_FLOAT = 3
};

enum ZUI_STYLEABLE {
    ZS_DONE = 0,
    ZSC_BACKGROUND,
    ZSC_FOREGROUND,
    ZSC_HOVERED,
    ZSC_UNFOCUSED,
    ZSV_PADDING,
    ZSV_SPACING,
    ZSV_BORDER,
};

enum ZUI_FLAGS {
    ZJ_CENTER = 0, // justification flags
    ZJ_LEFT =   1 << 0,
    ZJ_RIGHT =  1 << 1,
    ZJ_UP =     1 << 2,
    ZJ_DOWN =   1 << 3,
    ZF_CONTAINER = 1 << 4, // a container (saves style changes for itself and children)
    ZF_PARENT =    1 << 5, // a container with children
    ZF_TABBABLE =  1 << 6, // pressing tab can focus to this element
    ZF_DISABLED =  1 << 7, // not selectable (ui_pos ignores it for hovered/focused consideration)
    ZF_FILL_X    = 1 << 8, // force used.w to equal bounds.w after initial size calculation
    ZF_FILL_Y    = 1 << 9  // force used.h to equal bounds.h after initial size calculation
};

// commands generated by zui
enum ZUI_CMDS {
    ZCMD_INIT,
    ZCMD_TICK,
        // _ZCMD_INIT,     // new client
    ZCMD_CLOSE,
        // _ZCMD_CLOSE,    // client disconnects
    ZCMD_RENDER_BEGIN,
    ZCMD_RENDER_END,
    ZCMD_REG_FONT,
        // _ZCMD_FONT,     // client tells whether it was successful
    ZCMD_DRAW_CLIP,
    ZCMD_DRAW_RECT,
    ZCMD_DRAW_TEXT,
    ZCMD_POLL_EVENTS,
        // _ZCMD_KEYCODE,   // zui_key_char
        // _ZCMD_MOUSE,     // zcmd *zui_mouse_*
        // _ZCMD_RESIZE,    // zcmd *zui_resize(u16 w, u16 h);
    ZCMD_SET_CLIPBOARD,
    ZCMD_GET_CLIPBOARD,
        // _ZCMD_CLIPBOARD, // zcmd *zui_clipboard(char *);
    ZCMD_GLYPH_SZ,
        // _ZCMD_GLYPH_SZ,  // zcmd *zui_set_glyph(u16 font_id, i32 codepoint, zvec2 sz);
};

typedef struct zglyph_data { u16 font_id; u16 width; i32 c; } zglyph_data;
typedef struct zcmd_clip { zcmd header; zrect rect; } zcmd_clip;                                          // set clip rect
typedef struct zcmd_rect { zcmd header; zrect rect; zcolor color; } zcmd_rect;                            // draw rect
typedef struct zcmd_text { zcmd header; zvec2 pos;  zcolor color; u16 font_id; char text[0]; } zcmd_text; // draw text
typedef struct zcmd_get_clipboard { zcmd header; char *response; } zcmd_get_clipboard;                    // get clipboard
typedef struct zcmd_set_clipboard { zcmd header; char text[0]; } zcmd_set_clipboard;                      // set clipboard
typedef struct zcmd_reg_font { zcmd header; u16 font_id; u16 size; bool response; char family[0]; } zcmd_reg_font;               // register font
typedef struct zcmd_glyph { zcmd header; zglyph_data c; } zcmd_glyph;
typedef union {
    zcmd base;
    zcmd_clip clip;
    zcmd_rect rect;
    zcmd_text text;
    zcmd_reg_font font;
    zcmd_glyph glyph;
    zcmd_set_clipboard set_clipboard;
    zcmd_get_clipboard get_clipboard;
} zcmd_any;

typedef void(*zui_render_fn)(zcmd_any *cmd, void *user_data);
typedef void(*zui_log_fn)(char *fmt, va_list args, void *user_data);
typedef void(*zui_init_fn)(void *user_data);
typedef void(*zui_frame_fn)(void *user_data);
typedef void(*zui_close_fn)(void *user_data);

typedef struct zimpl {
    void *impl_data;
    zui_render_fn renderer;
} zimpl;

void zui_launch(zimpl implementation, void *settings);

typedef struct zccmd_mouse { zcmd header; zvec2 pos; u16 state; } zccmd_mouse;     // mouse movement / state
typedef struct zccmd_keys { zcmd header; u32 key; u16 modifiers; } zccmd_keys;     // key presses
typedef struct zccmd_glyph { zcmd header; zglyph_data c; } zccmd_glyph;            // sent every time a new glyph needs to be displayed
typedef struct zccmd_win { zcmd header; zvec2 sz; } zccmd_win;                     // new window size
typedef struct zccmd_font { zcmd header; u32 status; } zccmd_stat;                 // response to server command 
typedef union zccmd {
    zcmd        base;
    zccmd_mouse mouse;
    zccmd_keys  keys;
    zccmd_glyph glyph;
    zccmd_win   win;
    zccmd_stat  status;
} zccmd;

enum ZUI_WIDGETS {
    ZW_FIRST,
    ZW_BLANK = ZW_FIRST,
    ZW_WINDOW,
    ZW_BOX,
    ZW_POPUP,
    ZW_LABEL,
    ZW_ROW,
    ZW_COL,
    ZW_BTN,
    ZW_CHECK,
    ZW_TEXT,
    ZW_COMBO,
    ZW_GRID,
    ZW_TABSET
};

typedef struct zw_base { u16 id, bytes; i32 next, zindex, flags; zrect bounds; zrect used; } zw_base;
typedef struct zw_cont { u16 id, bytes; i32 next, zindex, flags; zrect bounds; zrect used; u16 children; u16 style_edits; } zw_cont;

#define Z_WIDGET union { zcmd cmd; zw_base widget; }
#define Z_CONT   union { zcmd cmd; zw_base widget; zw_cont cont; }

typedef struct zd_text { i32 flags, index, ofs, selection; } zd_text;

typedef struct zw_box    { Z_CONT; } zw_box;
typedef struct zw_layout { Z_CONT; i32 count; float data[1]; } zw_layout;
typedef struct zw_grid   { Z_CONT; u8 rows, cols, padx, pady; float data[1]; } zw_grid;
typedef struct zw_tabset { Z_CONT; char *cstabs; i32 *state; u16 label_cnt; u16 tabheight; } zw_tabset;
typedef struct zw_text   { Z_WIDGET; char *buffer; i32 len; zd_text *state; } zw_text;
typedef struct zw_btn    { Z_CONT; u8 *state; } zw_btn;
typedef struct zw_check  { Z_WIDGET; u8 *state; } zw_check;
typedef struct zw_combo  { Z_WIDGET; char *tooltip, *csoptions; i32 *state; } zw_combo;
typedef struct zw_label  { Z_WIDGET; char *text;  i32 len; } zw_label;

#ifdef ZUI_UTF8
i32  utf8_val(char *text, u32 codepoint);
i32  utf8_len(u32 codepoint);
void utf8_print(char *text, i32 len);
#endif

#ifdef ZUI_BUF
void zbuf_init(zui_buf *l, i32 cap, i32 alignment);
void *zbuf_alloc(zui_buf *l, i32 size);
i32  zbuf_align(zui_buf *l, i32 n);
void *zbuf_peek(zui_buf *l, i32 size);
void *zbuf_pop(zui_buf *l, i32 size);
#endif

#ifdef ZUI_MAP
typedef struct zmap zmap;
void zmap_init(zmap *map);
u32  zmap_hash(u32 n);
void zmap_set(zmap *map, u32 key, u32 value);
bool zmap_get(zmap *map, u32 key, u32 *value);
#endif

// CLIENT COMMANDS
// void zui_client_init(zui_client_fn send, zui_render_fn recv, zui_log_fn logger, void *user_data);
// void zui_client_push_raw(char *bytes, i32 len);
// void zui_client_push(zscmd *cmd);
// void zui_client_respond(i32 value);
// void zui_client_render();


// this sends a ZCMD_TICK command to the renderer function
void zui_tick(bool blocking);

void zui_mouse_down(u16 btn);
void zui_mouse_up(u16 btn);
void zui_mouse_move(zvec2 pos);
void zui_key_mods(u16 mod);
void zui_key_char(i32 c);
void zui_resize(u16 width, u16 height);

void zui_fill(u32 axis);

// SERVER COMMANDS
void zui_init(zui_render_fn renderer, zui_log_fn logger, void *user_data);
void zui_push(zccmd *cmd);
void zui_render();
u32 zui_ms();

void zui_print_tree();

void zui_close();
void zui_blank();
void zui_box();
void zui_popup();
void zui_justify(u32 justification);

// sets the style for the next container
void zui_style(u32 widget_id, ...);

zcolor zui_stylec(u16 widget_id, u16 style_id);
zvec2  zui_stylev(u16 widget_id, u16 style_id);
float  zui_stylef(u16 widget_id, u16 style_id);
i32    zui_stylei(u16 widget_id, u16 style_id);

//void zui_size(i32 w, i32 h);
u16  zui_new_font(char *family, i32 size);
zvec2 zui_text_sz(u16 id, char *text, i32 len);
void zui_font(u16 id);

void zui_end();
void zui_window();
zvec2 zui_window_sz();
void zui_label(const char *text);
void zui_sliderf(char *tooltip, f32 min, f32 max, f32 *value);
void zui_slideri(char *tooltip, i32 min, i32 max, i32 *value);
i32  zui_combo(char *tooltip, char *csoptions, i32 *state);
bool zui_button(const char *text, u8 *state);
bool zui_check(u8 *state);
void zui_validator(bool(*validator)(char *text));
void zui_text(char *buffer, i32 len, zd_text *state);
void zui_textbox(char *buffer, i32 len, i32 *state);
void zui_col(i32 n, float *heights);
void zui_row(i32 n, float *widths);
void zui_grid(i32 cols, i32 rows, float *col_row_settings);
void zui_tabset(char *cstabs, i32 *state);

#ifdef __cplusplus 
}
#endif

#endif
