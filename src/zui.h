#include <stdbool.h>
#include <stdarg.h>

#ifndef TYPES_INCLUDED
#define TYPES_INCLUDED
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;
typedef unsigned long long u64;

typedef char i8;
typedef short i16;
typedef int i32;
typedef long long i64;

typedef float f32;
typedef double f64;
#endif

#ifndef ZUI_INCLUDED
#define ZUI_INCLUDED

#ifdef __cplusplus 
extern "C" {
#endif

#define Z_AUTO 32766
#define Z_AUTO_ALL 32767
#define Z_FILL -1

typedef struct zcmd { u16 id, bytes; } zcmd;
typedef struct zcolor { u8 r, g, b, a; } zcolor;
typedef union zvec2 { struct { i16 x, y; }; i16 e[2]; } zvec2;
typedef union zrect { struct { i16 x, y, w, h; }; struct { zvec2 pos; zvec2 sz; }; i16 e[4]; } zrect;

enum ZUI_KEYS {
    ZK_L_SHIFT = 1 << 0,
    ZK_R_SHIFT = 1 << 1,
    ZK_SHIFT = ZK_L_SHIFT | ZK_R_SHIFT,
    ZK_L_CTRL = 1 << 2,
    ZK_R_CTRL = 1 << 3,
    ZK_CTRL = ZK_L_CTRL | ZK_R_CTRL,
    ZK_L_ALT = 1 << 4,
    ZK_R_ALT = 1 << 5,
    ZK_ALT = ZK_L_ALT | ZK_R_ALT,
    ZK_CAPSLOCK = 1 << 6,
    ZK_SUPER = 1 << 7,
#if defined(_WIN32)
    ZK_SHORTCUT = ZK_CTRL,
#elif defined(__APPLE__) && defined(__MACH__)
    ZK_SHORTCUT = ZK_SUPER,
#endif
};

enum ZUI_MOUSE {
    ZM_LEFT_CLICK = 1,
    ZM_RIGHT_CLICK = 2,
    ZM_MIDDLE_CLICK = 4
};

enum ZUI_STYLETYPE {
    ZS_COLOR = 0,
    ZS_VEC2 = 1,
    ZS_INT = 2,
    ZS_FLOAT = 3
};

enum ZUI_STYLEABLE {
    ZS_DONE = 0,
    ZSC_BACKGROUND,
    ZSC_FOREGROUND,
    ZSC_HOVERED,
    ZSC_UNFOCUSED,
    ZSV_PADDING,
    ZSV_SPACING,
    ZSV_BORDER,
    ZS_LAST,
};

enum ZUI_FLAGS {
    ZJ_CENTER = 0, // justification flags
    ZJ_LEFT =   1 << 0,
    ZJ_RIGHT =  1 << 1,
    ZJ_UP =     1 << 2,
    ZJ_DOWN =   1 << 3,
    ZF_CONTAINER = 1 << 4, // a container (saves style changes for itself and children)
    ZF_PARENT =    1 << 5, // a container with children
    ZF_TABBABLE =  1 << 6, // pressing tab can focus to this element
    ZF_DISABLED =  1 << 7, // not selectable (ui_pos ignores it for hovered/focused consideration)
    ZF_FILL_X    = 1 << 8, // force used.w to equal bounds.w after initial size calculation
    ZF_FILL_Y    = 1 << 9  // force used.h to equal bounds.h after initial size calculation
};

// commands generated by zui
enum ZUI_CMDS {
    ZCMD_INIT,
    ZCMD_TICK,
        // _ZCMD_INIT,     // new client
    ZCMD_CLOSE,
        // _ZCMD_CLOSE,    // client disconnects
    ZCMD_RENDER_BEGIN,
    ZCMD_RENDER_END,
    ZCMD_REG_FONT,
        // _ZCMD_FONT,     // client tells whether it was successful
    ZCMD_DRAW_CLIP,
    ZCMD_DRAW_RECT,
    ZCMD_DRAW_TEXT,
    ZCMD_DRAW_BEZIER,
        // _ZCMD_KEYCODE,   // zui_key_char
        // _ZCMD_MOUSE,     // zcmd *zui_mouse_*
        // _ZCMD_RESIZE,    // zcmd *zui_resize(u16 w, u16 h);
    ZCMD_SET_CLIPBOARD,
    ZCMD_GET_CLIPBOARD,
        // _ZCMD_CLIPBOARD, // zcmd *zui_clipboard(char *);
    ZCMD_GLYPH_SZ,
    ZCMD_TIMESTAMP
        // _ZCMD_GLYPH_SZ,  // zcmd *zui_set_glyph(u16 font_id, i32 codepoint, zvec2 sz);
};

typedef struct zcmd_clip { zcmd header; zrect rect; } zcmd_clip;                                          // set clip rect
typedef struct zcmd_rect { zcmd header; zrect rect; zcolor color; } zcmd_rect;                            // draw rect
typedef struct zcmd_text { zcmd header; zvec2 pos;  zcolor color; u16 font_id; char text[0]; } zcmd_text; // draw text
typedef struct zcmd_bezier { zcmd header; zcolor color; i32 width; zvec2 points[0]; } zcmd_bezier;        // draw bezier
typedef struct zcmd_get_clipboard { zcmd header; char *response; } zcmd_get_clipboard;                    // get clipboard
typedef struct zcmd_set_clipboard { zcmd header; char text[0]; } zcmd_set_clipboard;                      // set clipboard
typedef struct zcmd_reg_font { zcmd header; u16 font_id; u16 size; u16 response_height; char family[0]; } zcmd_reg_font; // register font
typedef struct zcmd_glyph_sz { zcmd header; u16 font_id; i32 codepoint; zvec2 response; } zcmd_glyph_sz; // get text size
typedef struct zcmd_timestamp { zcmd header; u64 resp_ns; } zcmd_timestamp;
typedef union {
    zcmd base;
    zcmd_clip clip;
    zcmd_rect rect;
    zcmd_text text;
    zcmd_bezier bezier;
    zcmd_reg_font font;
    zcmd_glyph_sz glyph_sz;
    zcmd_timestamp timestamp;
    zcmd_set_clipboard set_clipboard;
    zcmd_get_clipboard get_clipboard;
} zcmd_any;

typedef void(*zui_render_fn)(zcmd_any *cmd, void *user_data);
typedef void(*zui_log_fn)(char *fmt, va_list args, void *user_data);
typedef void(*zui_init_fn)(void *user_data);
typedef void(*zui_frame_fn)(void *user_data);
typedef void(*zui_close_fn)(void *user_data);

typedef struct zimpl {
    void *impl_data;
    zui_render_fn renderer;
} zimpl;

void zui_launch(zimpl implementation, void *settings);

typedef struct zccmd_mouse { zcmd header; zvec2 pos; u16 state; } zccmd_mouse;     // mouse movement / state
typedef struct zccmd_keys { zcmd header; u32 key; u16 modifiers; } zccmd_keys;     // key presses
//typedef struct zccmd_glyph { zcmd header; zglyph_data c; } zccmd_glyph;            // sent every time a new glyph needs to be displayed
typedef struct zccmd_win { zcmd header; zvec2 sz; } zccmd_win;                     // new window size
typedef struct zccmd_font { zcmd header; u32 status; } zccmd_stat;                 // response to server command 
typedef union zccmd {
    zcmd        base;
    zccmd_mouse mouse;
    zccmd_keys  keys;
    //zccmd_glyph glyph;
    zccmd_win   win;
    zccmd_stat  status;
} zccmd;

enum ZUI_WIDGETS {
    ZW_FIRST,
    ZW_BLANK = ZW_FIRST,
    ZW_WINDOW,
    ZW_BOX,
    ZW_POPUP,
    ZW_LABEL,
    ZW_LABELF,
    ZW_ROW,
    ZW_COL,
    ZW_SCROLL,
    ZW_BTN,
    ZW_CHECK,
    ZW_TEXT,
    ZW_COMBO,
    ZW_GRID,
    ZW_TABSET,
    ZW_LAST
};

typedef struct zw_base { u16 id, bytes; i32 next, zindex, flags; zrect bounds; zrect used; } zw_base;
typedef struct zw_cont { u16 id, bytes; i32 next, zindex, flags; zrect bounds; zrect used; u16 children; u16 style_edits; } zw_cont;

#define Z_WIDGET union { zcmd cmd; zw_base widget; }
#define Z_CONT   union { zcmd cmd; zw_base widget; zw_cont cont; }

typedef struct zd_text { i32 flags, index, ofs, selection; } zd_text;

typedef struct zw_box    { Z_CONT; } zw_box;
typedef struct zw_layout { Z_CONT; i32 count; i16 sizes[0]; } zw_layout;
typedef struct zw_grid   { Z_CONT; u8 rows, cols, padx, pady; float data[1]; } zw_grid;
typedef struct zw_tabset { Z_CONT; char *cstabs; i32 *state; u16 label_cnt; u16 tabheight; } zw_tabset;
typedef struct zw_text   { Z_WIDGET; char *buffer; i32 len; zd_text *state; } zw_text;
typedef struct zw_btn    { Z_CONT; u8 *state; } zw_btn;
typedef struct zw_check  { Z_WIDGET; u8 *state; } zw_check;
typedef struct zw_combo  { Z_WIDGET; char *tooltip, *csoptions; i32 *state; } zw_combo;
typedef struct zw_label  { Z_WIDGET; char *text; i32 len; } zw_label;
typedef struct zw_labelf { Z_WIDGET; char text[0]; } zw_labelf;
typedef struct zw_scroll { Z_CONT; bool xbar, ybar; zvec2 *state; } zw_scroll;

#ifdef ZUI_DEV
#define FOR_CHILDREN(ui) for(zw_base* child = _ui_get_child((zw_base*)ui); child != (zw_base*)ui; child = _ui_next(child))
#define FOR_SIBLINGS(ui, sibling) for(zw_base* child = (zw_base*)sibling; child != (zw_base*)ui; child = _ui_next(child))
#define FOR_N_SIBLINGS(ui, sibling, n) for(i32 i = 0; sibling != (zw_base*)ui && i < n; sibling = _ui_next(sibling), i++)
#define SWAP(type, a, b) { type tmp = a; a = b; b = tmp; }

zw_base *_ui_widget(i32 index);
i32 _ui_index(zw_base *ui);
zw_base *_ui_next(zw_base *widget);
void *_ui_alloc(i32 id, i32 size);
void *_cont_alloc(i32 id, i32 size);
void *_draw_alloc(u16 id, u16 size, i32 zindex);
zrect _rect_add(zrect a, zrect b);
zrect _rect_pad(zrect r, zvec2 padding);
void _push_rect_cmd(zrect rect, zcolor color, i32 zindex);
void _push_clip_cmd(zrect rect, i32 zindex);
void _push_text_cmd(u16 font_id, zvec2 coord, zcolor color, char *text, i32 len, i32 zindex);
void _push_bezier_cmd(i32 cnt, zvec2 *points, i32 width, zcolor color, i32 zindex);
zvec2 _vec_max(zvec2 a, zvec2 b);
zvec2 _vec_min(zvec2 a, zvec2 b);
zvec2 _vec_add(zvec2 a, zvec2 b);
zvec2 _vec_sub(zvec2 a, zvec2 b);
i32 _vec_distsq(zvec2 a, zvec2 b);
bool _vec_within(zvec2 v, zrect bounds);
bool _rect_within(zrect r, zrect bounds);
bool _rect_intersect(zrect a, zrect b, zrect *intersect);
void _rect_justify(zrect *used, zrect bounds, i32 justification);
void _ui_schedule_focus(zw_base *widget);
zw_base *_ui_find_with_flag(zw_base *start, u32 flags);
zw_base *_ui_get_child(zw_base *ui);
bool _ui_pressed(i32 buttons);
bool _ui_dragged(i32 buttons);
bool _ui_clicked(i32 buttons);
bool _ui_released(i32 buttons);
void _ui_print(zw_base *cmd, int indent);
zvec2 _ui_mpos();
zvec2 _ui_mdelta();
i16 _ui_sz(zw_base *ui, bool axis, i16 bound);
bool _ui_is_child(zw_base *container, zw_base *other);
bool _ui_hovered(zw_base *ui);
bool _ui_cont_hovered(zw_base *ui);
bool _ui_focused(zw_base *ui);
bool _ui_cont_focused(zw_base *ui);
void _ui_pos(zw_base *ui, zvec2 pos, i32 zindex);
void _ui_draw(zw_base *ui);
void zui_register(i32 widget_id, void *size_cb, void *pos_cb, void *draw_cb);
void zui_default_style(u32 widget_id, ...);
i32 zui_new_sid();
i32 zui_new_wid();
#endif

#ifdef ZUI_UTF8
i32  utf8_val(char *text, u32 codepoint);
i32  utf8_len(u32 codepoint);
void utf8_print(char *text, u32 codepoint, i32 len);
#endif

#ifdef ZUI_BUF
typedef struct zui_buf {
    i32 used;
    u16 cap;
    u16 alignsub1;
    u8 *data;
} zui_buf;
void zbuf_resize(zui_buf *l);
void zbuf_init(zui_buf *l, i32 cap, i32 alignment);
void *zbuf_alloc(zui_buf *l, i32 size);
i32  zbuf_align(zui_buf *l, i32 n);
void *zbuf_peek(zui_buf *l, i32 size);
void *zbuf_pop(zui_buf *l, i32 size);
#endif

#ifdef ZUI_MAP
typedef struct zmap zmap;
void zmap_init(zmap *map);
u32  zmap_hash(u32 n);
void zmap_set(zmap *map, u32 key, u32 value);
bool zmap_get(zmap *map, u32 key, u32 *value);
#endif

// CLIENT COMMANDS
// void zui_client_init(zui_client_fn send, zui_render_fn recv, zui_log_fn logger, void *user_data);
// void zui_client_push_raw(char *bytes, i32 len);
// void zui_client_push(zscmd *cmd);
// void zui_client_respond(i32 value);
// void zui_client_render();

void zui_log(char *fmt, ...);

// this sends a ZCMD_TICK command to the renderer function
void zui_tick(bool blocking);

void zui_mouse_down(u16 btn);
void zui_mouse_up(u16 btn);
void zui_mouse_move(zvec2 pos);
void zui_key_mods(u16 mod);
void zui_key_char(i32 c);
void zui_resize(u16 width, u16 height);

void zui_fill(u32 axis);

// SERVER COMMANDS
void zui_init(zui_render_fn renderer, zui_log_fn logger, void *user_data);
void zui_push(zccmd *cmd);
void zui_render();
u32 zui_ms();

void zui_print_tree();

void zui_close();
void zui_blank();
void zui_box();
void zui_popup();
void zui_justify(u32 justification);

// sets the style for the next container
void zui_style(u32 widget_id, ...);

zcolor zui_stylec(u16 widget_id, u16 style_id);
zvec2  zui_stylev(u16 widget_id, u16 style_id);
float  zui_stylef(u16 widget_id, u16 style_id);
i32    zui_stylei(u16 widget_id, u16 style_id);

//void zui_size(i32 w, i32 h);
u16  zui_new_font(char *family, i32 size);
//zvec2 zui_text_sz(u16 id, char *text, i32 len);
void zui_font(u16 id);

void zui_end();
void zui_window();
zvec2 zui_window_sz();
void zui_label(const char *text);
void zui_labelf(const char *fmt, ...);
void zui_sliderf(char *tooltip, f32 min, f32 max, f32 *value);
void zui_slideri(char *tooltip, i32 min, i32 max, i32 *value);
i32  zui_combo(char *tooltip, char *csoptions, i32 *state);
bool zui_button(u8 *state);
bool zui_button_txt(const char *text, u8 *state);
bool zui_check(u8 *state);
void zui_scroll(bool xbar, bool ybar, zvec2 *state);
void zui_validator(bool(*validator)(char *text));
void zui_text(char *buffer, i32 len, zd_text *state);
void zui_textbox(char *buffer, i32 len, i32 *state);
void zui_col(i32 n, ...);
void zui_row(i32 n, ...);
void zui_grid(i32 cols, i32 rows, float *col_row_settings);
void zui_tabset(char *cstabs, i32 *state);

#ifdef __cplusplus 
}
#endif

#endif
